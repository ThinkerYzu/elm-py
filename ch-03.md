# CHAPTER 03 - 資料型別

大部分程式語言支援多種類別的資料，列如，整數、乳點數、字串、
陣列 ... 等等。
基本上，資料型別可以分成兩大類， primitive type 和 compound type。
primitive type 如整數、淨點數等。
這類別的資料通常佔空間小，容易直接複製也不會造成大太的效能問題。
而且，幾乎都能被處理理 (CPU) 處理。
primitive type 是程式語言裡最基本的資料型別。

compound type 是用來容納多個 primitive type 和其它 compound type
型別。例如，list (Python 可變長度的陣列) 就是用來存放不固定數量
任何類別的資料。你可以存 n 筆資料在 list, 並用引數存取特定位置的內容。

## Primitive Types

### 整數

整數如 0, 1, 2, 3 ....., -1, -2, ....。不帶小數點。
大部分程式語言，整數有大小的限制。
如果 32bits 的平台上, 整數的範圍可能是最大 2 的 31 次方減 1，
最小負 2 的 31 次方。
但 Python 支援無限大的整數，只要你的記憶體夠大。
試在 Python 的「提示符號」後嘗試下列指令，並觀察其輸出。

 - 2 ** 31
 - 2 ** 100 + 2 ** 60

以上 \*\* 代表指數，  2 \*\* 31 代表 2 的 31 次方。

### 浮點數

Python 和大多數程式語言一樣，使用浮點數存放實數。
實數可以有小數點，如 3.14。
事實上，只要加上小數點，如 1.0，就會被 Python 當成浮點數。
然而浮點數並不是完全精確的，會有誤差。
請試試下列指令。

 - 8.3 ** 100
 - 8.3 ** 100 + 1.7
 - 8.3 ** 100 + 1.7 == 8.3 ** 100
 - 9 ** 100 + 1 == 9 ** 100

前兩行算出來的結果是一樣的, 而第三行算出是 True。
這是因為浮點數的精度有限, 相對於 8.3 \*\* 100，1.7 實在太小了，
所以將太小的部分忽略。
第四行算出來是 False。
因為它是整數，而 Python 的整數可以無限大，不會有精準度的問題。

    a = 3.0
    b = 2.0
    while a != b:
        b = b * 2.0
        a = b + 1.0
    print(b)

上面程式，在大到一定程度之後, b 和 a 就沒什麼不同了。
因為 1.0 實在太小了，所以被忽略了。

    a = 3.0
    b = 2.0
    while a != b:
        b = b * 2.0
        a = b + 100.0
    print(b)

上方程式和前一個程式差不多, 但因為這次是加 100.0，比 1.0 大很多。
因此在數字更大時，才會被忽略。
換句話說, 當數字本身愈大時，其精確度就愈低。
例如，一開始是數字小時，小於 0.00001 的部分會被忽略。
隨著數字變大時，
可能小於 0.001 的部分就會被被忽略。
進一步變大時, 就變成 100.0 以下會被忽略。
數字變大，忽略愈多。
「數字變大」是指數字的絕對值變大。

另外，Python 也技援科學表示法，也就是指數。

 - 1.3e100
 - 1.3 * (10.0 ** 100)

這兩行的結果是相等的。e 後面的數字代表 10 的次方。

在入門階段，浮點數的細節並不重要。
但未來在實際應用時，必需更透徹瞭解其特性，處理其誤差。
更詳細資料請參考 Wikipedia。

 - https://zh.wikipedia.org/zh-tw/%E6%B5%AE%E7%82%B9%E6%95%B0

### 整數和浮點數除法

請在 Python 的「提示符號」後，試試下列指令。

 - 3 / 3
 - 3 // 3

兩行都是除法，但結果有點不同。
第一行計算後，會變成浮點數，即使兩個運算元(運算子的參數)都是整數。
第二行的結果則是整數。
Python 3.0+ 有兩種除法運算子，第一行的是浮點數的除法，而第二行是整數除法。

再試試下面指令。

 - 3 / 2
 - 3 // 2

第一行的結果是浮點數 1.5，而第二行是整數 1。
整數除法會無條件捨去小數的部分。

## 餘數

 - 5 % 3
 - 5.2 % 3
 - 5 % 3.1

以上三行取餘數。
以第一行為例，5 除以 3 的餘數為 2。
取餘數的運算子，只要其左邊或右邊任何一個運算元為浮點數，其結果就是浮點數。

## Compound Types

compound type 指各種能將其它資料型別的資料，打包在一起的型別。

### List

list 是 Python 最常用的 compound type，
它是一串資料的組合，裏面每一個資料給一個位置，從 0 開始給號到
n - 1，共 n 個位置。
而 list 的長度是可以變動的，可隨時增加或縮短其長度。

 - a = [1, 3, 5, 7, 9]
 - a[0]
 - a[1]
 - a[-1]
 - a[-2]

以上第一行是建立一個長度為 5 的 list，內容分別是 1, 3, 5, 7 和 9。
後四行是用引數，也就是位置，讀取其內容。
引數是從 0 開始數，位置 0 的內容為 1，位置 1 的內容為 3。
負數的引數是從 list 的尾端 (最右邊的元素) 回頭算，-1 的內容為 9，
-2 的內容為 7。

    data = [1, 3, 5, 7, 9]
    total = 0
    i = 0
    while i < len(data):
        total = total + data[i]
        i = i + 1
    print('Total: {}'.format(total))

以上範例將 data 的內容加總之後印出。
len(data) 傳回 data 對映的 list 的長度，而 i 則從 0 開始，
在 while-loop 裡每次加 1，直到 5，也就是 data 的長度，
然後離開迴圈。

像這樣把 list 內容一個接著一個取出的情況很常見，於是 Python
有一個特別的語法，能簡化程式。

    data = [1, 3, 5, 7, 9]
    total = 0
    for v in data:
        total = total + v
    print('Total: {}'.format(total))

第三行是 for-loop，for 和 in 是關鍵字。
在兩者中間的 v 是變數名稱，for-loop 會把 in 右邊的 list 內容，
依序一次一個指定給 v。
此例中，第一次先把 data[0]，內容為 1, 指定給 v，然後執行後面的區塊。
第二次則把 data[1]，內容為 3，指定給 v，然後執行區塊內容。
每次到區塊結束的位置，就會跳回 for 那一行，把 list 裡下一個位置的內容
指定給變數 v，並執行區塊，直到 list 的結束位置。

請問

 1. 第四行執行幾次?
 2. 最後印出的值為何?

請試執行下例。

    data = [0, 1]
    for i in range(10):
        v = data[-1] + data[-2]
        data.append(v)
    print('data: {}'.format(data))

range() 是一個特別的函數，range(10) 會傳回一個 0, 1, ... 9 的數列。
因此，第二行就是一個會執行 10 次的迴圈。
而 i，則從 0 開始，每次加 1，直到 9，最後一次執行後離開。
data[-1] 和 data[-2] 如我們前面說過的，負數的引數是從 list 的後面往回數。

append() 是 list 的一個特別的功能/方法 (method)，能將參數的內容
附加到 list 的尾端，使其長度加 1。

請注意印出的內容!
