# CHAPTER 03 - 資料型別

大部分程式語言支援多種類別的資料，列如，整數、乳點數、字串、
陣列 ... 等等。
基本上，資料型別可以分成兩大類， primitive type 和 compound type。
primitive type 如整數、淨點數等。
這類別的資料通常佔空間小，容易直接複製也不會造成大太的效能問題。
而且，幾乎都能被處理理 (CPU) 處理。
primitive type 是程式語言裡最基本的資料型別。

compound type 是用來容納多個 primitive type 和其它 compound type
型別。例如，list (Python 可變長度的陣列) 就是用來存放不固定數量
任何類別的資料。你可以存 n 筆資料在 list, 並用引數存取特定位置的內容。

## Primitive Types

### 整數

整數如 0, 1, 2, 3 ....., -1, -2, ....。不帶小數點。
大部分程式語言，整數有大小的限制。
如果 32bits 的平台上, 整數的範圍可能是最大 2 的 31 次方減 1，
最小負 2 的 31 次方。
但 Python 支援無限大的整數，只要你的記憶體夠大。
試在 Python 的「提示符號」後嘗試下列指令，並觀察其輸出。

 - 2 ** 31
 - 2 ** 100 + 2 ** 60

以上 \*\* 代表指數，  2 \*\* 31 代表 2 的 31 次方。

### 浮點數

Python 和大多數程式語言一樣，使用浮點數存放實數。
實數可以有小數點，如 3.14。
事實上，只要加上小數點，如 1.0，就會被 Python 當成浮點數。
然而浮點數並不是完全精確的，會有誤差。
請試試下列指令。

 - 8.3 ** 100
 - 8.3 ** 100 + 1.7
 - 8.3 ** 100 + 1.7 == 8.3 ** 100
 - 9 ** 100 + 1 == 9 ** 100

前兩行算出來的結果是一樣的, 而第三行算出是 True。
這是因為浮點數的精度有限, 1.7 相對於 8.3 \*\* 100 實在太小了，
所以將太小的部分忽略。
第四個指令則不會有這個問題，因為它是整數，而 Python
的整數可以無限大。

    a = 3.0
    b = 2.0
    while a != b:
        b = b * 2.0
        a = b + 1.0
    print(b)

上面程式，在大到一定程度之後, b 和 a 就沒什麼不同了。
因為 1.0 實在太小了，所以被忽略了。

    a = 3.0
    b = 2.0
    while a != b:
        b = b * 2.0
        a = b + 100.0
    print(b)

上方程式和前一個程式差不多, 但因為這次是加 100.0，比 1.0 大很多。
因此在數字更大時，才會被忽略。
換句話說, 當數字本身愈大時，其精確度就愈低。
例如，一開始是數字小時，小於 0.00001 的部分會被忽略。
隨著數字變大時，
可能小於 0.001 的部分就會被被忽略。
進一步變大時, 就變成 100.0 以下會被忽略。
數字變大，忽略愈多。
「數字變大」是指數字的絕對值變大。

## Compound Types

