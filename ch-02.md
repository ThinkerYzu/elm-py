# CHAPTER 02 - 流程控制 (Branch)

Flow-control (流程控制) 的作用，依條件改變程式的走向。
程式通常不是像在 chapter 01 中看到的那樣，一直線一行接著一行
執行下來。一般分成多個如 chapter 01 裡的程式區塊，
並在程式區塊結束時, 決定接下來要跳到哪一個區塊繼續執行。又或是
回到同一區塊的起始點，重複的執行，直到滿足特定條件。

## IF-ELSE

    import random
    
    v = random.random()
    if v > 0.5:
        vv = v * v
        print('v * v == {}'.format(vv))
    else:
        vh = v / 2
        print('v / 2 == {}'.format(vh))
    print('THE END')

上面的程式是取一個亂數值，當該亂數大於 0.5 時，算出平方值。
否則，算出其二分之一。
第一行, 是引入亂數的 module (模組)。Python 的一個 module 是提供
一組相關的功能。例如第一行引入 random 這個 module，就是告訴 Python
載入這模組提供亂數的功能。
第三行是呼叫 random 這個模組下, random() 這個 function (函數)。random()
傳回一個大於等於 0, 但小於 1.0 的亂數值。
第四行判斷該值 (變數 v) 是否大於 0.5，如果是, 就執行第五、六行。
否則, 執行第八、九行。
注意這邊的語法, 第四行，if 和 : 之間是判斷的條件，這一行要以冒號 (:) 結束。
接下來的第五、六行, 要縮排，也就是加上固定數量的空白。
例如全都是四個空白, 或是固定八個空白。
如果 if 後面的條件不成立, 就會往後找第一個 else: 指令，並執行其後的
區塊 (同樣縮排大小)。

第五、六兩行, 都是縮四個位置(四空白), 所以是同一個區塊。接下來的第七行
的縮排為 0, 沒縮排。和第五、六行不同，因此區塊結束了。
同樣的，第八、九行也組成一個區塊。
Python 以縮排的大小(空白的數量)決定這個區塊的範圍，因此數量、大小要固定。

最後, 不管 if 的條件成立與否，都會在執行完 if 或 else 後的區塊後，
執行接下來的最後一行。

if 後面不一定要有 else。如下

    import random
    
    v = random.random()
    if v > 0.5:
        vv = v * v
        print('v * v == {}'.format(vv))
    print('THE END')

因為後面沒有 else:, 所以在符合條件的情況下, 同樣執行第五、六行。
但在條件不成立時，就只是跳過第五、六行組成的區塊 (block)。
不管 if 的條件是否成立，在執行完 if 和其後的區塊後，都會接著執行第七行。

    import random
    
    v = random.random()
    if v > 0.5:
        vv = v * v
        print('v * v == {}'.format(vv))
    if v < 0.3:
        vh = v / 2
        print('v / 2 == {}.format(vh))
    else:
        print('v == {}.format(v))
    print('THE END')

這一段程式，第一個 if 後面沒有 else, 而是接著另一個 if，
所以在條件不成立時, 是直接跳過。
倒數第三行的 else，則是屬於第二個 if 的 else。
所以, 在 v > 0.5 是, 會印出 v * v。
而 v < 0.3 時, 則印出 v / 2。
但在 v < 0.3 不成立時, 會印出 v。

注意! 當 v > 0.5 時，例如 v 等於 0.7 , v < 0.3 就不成立。
因此，執第到第二個 if 時, 會跳到它的 else 的區塊(倒數第二行)執行。
也就是 v > 0.5 時，因為符合第一個 if 的條件，會先印出 v * v，
然後因為不符合第二個 if 的條件，而接著印出 v。

再次提醒，大寫和小寫是不同的。 if 和 else 一定是小寫，否則 Python
會認不出來。
後續其它的關鍵字也同樣，大小寫一定要正確 (小寫)。

## elif

    import random

    v = random.random()
    if v > 0.5:
        vv = v * v
        print('v * v == {}'.format(vv))
    elif v < 0.3:
        vh = v / 2
        print('v / 2 == {}.format(vh))
    else:
        print('v == {}.format(v))
    print('THE END')

前一個程式在 v > 0.5 時, 會印出 v * v 和 v。
而這個程式, v > 0.5 時, 就只會印出 v * v。
只有 v > 0.5 和 v < 0.3 都不成立時 (0.3 <= v <= 0.5)，
才印出 v。

這個程式和前一個差不多，差別在第七行變成 elif。
elif 和 if 差不多，但他相當於前一個 if 的 else。
當 if 條件不成立時, 會先看接下來的是 elif 或 else。
如果接下來沒有 elif 和 else, 那就整個跳過去，執行接下來的
其它指令。
如果，有 elif，就會試試 elif 右邊指定的條件成不成立。
成立時，就執行接在其後的 block，如這裡的第八、九行。
if 後面可以連續接很多個 elif。
當 if 條件不行立時，會依順序一個一個嘗試，直到找到第一個成立的
elif。
否則，就執行接在後面的 else。
如果沒 else，就跳過所有的 if 和 elif。

換句話說, 遇到 if，就會依次序嘗試 if 和其後所有的 elif，找到第一個
成立的條件，執行其後的區塊。
如果全都不成立，就執行 else。(else 永遠接在 elif 和 if 後面)
如果連 else 都沒有, 就全部跳過。

## Boolean (布林)

Boolean 有兩種值 True 和 False，分別代表「真」和「偽」，
或者「是」與「否」。前面 if 和 elif 右側的條件，其算出來的最終值
不是 True 就是 False。當算出來為 True 時，條件成立。
False 代表條件不成立。

    if True:
        print('It is true')
    if False:
        print('It is false')

上面程式只會印出 'It is true'。因為只有第一個 if 的條件是成立的。

請在「提示符號」後，嘗試以下條件 (命令)。

 - 1 > 0
 - 1 < 0
 - 1 >= 1
 - 1 > 1
 - 1 <= 1
 - 1 < 1
 - 1 == 1
 - 1 + 4 == 2 + 3

這些運算子，分別是大於(>)、小於(<)、大於等於 (>=)、小於等於 (<=) 和等於 (==)。
以上八行指令，運算結果分別是 True, False, True, False, True, False,
True 和 True。

請在 IDLE 或 Python 的 「提示符號」後，輸入下列指令。

 - a = 10
 - b = 20
 - c = 30
 - a < b and b < c
 - a < b and c < b
 - a < b or c < b
 - a > b or a > c

這裡有兩個邏輯運算子，分別是 and (且) 和 or (或)。
從第四行到第七行, and 和 or 運算子的左、右兩側會先運算，得出的 Boolean 值
(True 或 False) 再以該運算子運算。

假設我們有一變數 A，下面指令判斷 A 是否在 10 到 20 之間

 - A >= 10 and A <= 20

但如果我們希望 A 是落於 10 至 20 的範圍之外，有兩個寫法。

 - not (A >= 10 and A <= 20)
 - A < 10 or A > 20

not 運算子，會將其右邊的運算結果從 True 變成 False，或由 False 變成 True，
得到相反的結果。由於 not 的運算優先次序高於 and，因此用括號包起來，
讓括號裏面的 expression (表示式)先運算，然後才將結果做 not 運算。
如果沒加括號，結果相當於

 - (not A >= 10) and (A <= 20)

以下程式判斷一亂數是否在 10 至 20 的範圍。 

    import random
    A = random.random() * 30
    if A >= 10 and A <= 20:
        print('A is in the range: {}'.format(A))

第二行 random() 傳回 0 至 1.0 的亂數。乘上 30 後, 變成 0 至 30 範圍的亂數。

若對布林運算 (and 和 or) 有疑問，請參考 wikipedia。

 - https://zh.wikipedia.org/zh-tw/%E5%B8%83%E5%B0%94%E9%80%BB%E8%BE%91
 - https://zh.wikipedia.org/wiki/%E5%B8%83%E5%B0%94%E4%BB%A3%E6%95%B0

布林運算極為重要，沒有任何程式設計師可以在不懂布林代數的情況下勝任工作。
若您完全不懂布林代數，建議您好好的學好之後，再繼續往下。

## Nested if-else

if 或 else 的區塊裏，還能包括任何語法，包括其它 if 和 else。
這時，if 和 else 的區塊，需要更進一步縮排。例如下列程式，
第一層的 if 區塊縮排四個空白，而內層的 if 區塊，則更進一步，
縮排八個空白。

    import random
    A = random.random() * 30
    if A >= 10:
        B = random.random() * 30
        if A <= B:
            print('A {} is smaller than or equal to  B {}'.format(A, B))
        else:
            print('A {} is bigger than B {}'.format(A, B))
    else:
        print('A {} is smaller than 10'.format(A))

上面程式, 外層的 if 區塊包括 4~8 行。
而外層的 else, 則包括第 10 行。
內層的 if 區塊, 則包括第 6 行，而內層 else 區塊則是第 8 行。
每一層的 if 或 else 區塊都要往右縮固定的數量，例如此書習慣每層往右縮
四個空白。 

## While-loop

loop (迴圈)能讓程式重複執行同一段程式區塊。大部分 loop (迴圈)，會在
滿足特定條件時結束，並執行後續指令。

    a = 0
    b = 1
    counter = 0
    while counter < 4:
         c = a + b
         a = b
         b = c
         counter = counter + 1
    
    print('The 6th number of Fibonacci sequence is {}' \
          .format(b))

第四行是一個迴圈, 在滿足條件的情況下，不斷重複執行其後的
區塊(第 5~8 行)。
每次進入區塊之前，會先檢查 while 關鍵字和冒號 (:) 之間的條件
是否成立 (True)。
只有在滿足條件時，才會進入區塊執行。
當執行到區塊尾端時，又會跳回到 while 那一行，重新檢查條件，
並決定是否再一次進入區塊。
當條件不符合時 (False)，跳到區塊之後的第一個指令，第 10 行。
第 10 行因為過長，所以被切成兩行，並在最後加上一個倒斜號 (\\)。
倒斜號 (\\) 會讓 Python 的 Parser (分析器) 自動把下一行視為同一行。
也就是無視後面斷行符號，將之視為空白。
理論上，第 10 行可以不用加倒斜號 (\\)，因為前面有一個左括號，
parser 知道還有一個右括號，因此自動把下一行視為這一行的建伸，
你可以不加入這個倒斜號 (\\)。

## 程式狀態的變化

在前一程式中，a 和 b 不斷被修改。請問

 1. while 後面的區塊會執行幾次?
 2. while 右邊的條件會計算並檢查幾次?
 3. 每次進入 while 區塊時，a 和 b 值為何?
 4. 最後印出的數字為何?

追蹤各種條件和變數的變化，是學習程式設計很重要的一項練習。

## 從零開始

對程式設計師而言，有序離散的東西大部分是從 0 開始算起。
因此會有第 0 個 XXX，然後才是第 1 個 XXX，.... 第 n 個 XXX。
和平常人從 1 開始數的習慣不同。

前例的 counter 就是從 0 開始， while loop 的條件是 < 4，
所以 counter 會從 0, 1, 2, 3 一直到 4。
當 counter 為 4 時, 條件就不成立了，因此離開 while loop。

從 0 開始數有很多好處。例如, 有一個數列 <1, 3, 5, 7, 9, ....>。
該定參數 S 和 i，請問從數列第 S 個數字開始算起, S 後面的第 i 個數
字為何?
如果是傳統從 1 算起時，從 S 當起點，要算出第 i 個數字的位置會較麻煩。

    position = S + i - 1

你得先把 i 減掉 1 才行。例如 S=3, i=2。也就是從 S 開始算兩個，S 本身
是第 1 個，而 S + 1 是第 2 個。所以結果是 S+1 (== 4)，第 4 個數字，
而不是 S + 2，第 5 個數字。
而這種相對位置的換算，經常出現。
還時常出現數層的相對位置換算，例如，第 i 個算起的第 j, 其後算起的第 k 個
......。

從 0 算起，則沒這個問題，直接加上去就好。

    position = S + i

第 0 個數字是 1, 第 1 個數字是 3, 第 2 個數字是 5。
第 3 個數字算起的第 2 個數字是 3 + 2 == 5。
第 S 個數字算起的第 i 個數字是 S + i。

反過來，也常要計算 K 相對於 S 的位置。從 1 開始算時，

    offset = K - S + 1

例如，K=5, S=3, 那 K 相對於 S 的相對位置是 3, 而不是 5 - 3 == 2。
3 是從 S 算起的第 1 個, 4 是第 2，而 5 是第 3 個。

如果是從 0 開始算的情況。

    offset = K - S

S=3， K=5，第 S 開始算，第 0 個是 3 的位置，第 1 個是 4 的位置, 第 2 個是
5 的位置。
K 相對於 S，是第 2 個。

大部分的程式語言，大部分的狀況都是這樣數，從 0 開始。
您也必需開始習慣這種數法，能省卻你在 coding 時的許多麻煩。
